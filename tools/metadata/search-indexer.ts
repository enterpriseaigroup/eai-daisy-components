/**
 * Component Search Indexer
 *
 * Generates search metadata for component discovery.
 *
 * @fileoverview Search index generation
 * @version 1.0.0
 */

import { promises as fs } from 'fs';
import { join } from 'path';
import type { ComponentDefinition } from '@/types';

export interface SearchIndex {
  components: SearchableComponent[];
  metadata: {
    version: string;
    generatedAt: string;
    totalComponents: number;
  };
}

export interface SearchableComponent {
  name: string;
  type: string;
  description: string;
  keywords: string[];
  tags: string[];
  complexity: string;
  props: string[];
  businessLogic: string[];
  reactPatterns: string[];
  dependencies: string[];
  migrationStatus: string;
}

/**
 * Generate search index from components
 */
export async function generateSearchIndex(
  components: ComponentDefinition[],
  outputDir: string,
): Promise<string> {
  const indexPath = join(outputDir, 'component-search-index.json');

  const searchableComponents = components.map(c =>
    extractSearchableMetadata(c),
  );

  const index: SearchIndex = {
    components: searchableComponents,
    metadata: {
      version: '1.0.0',
      generatedAt: new Date().toISOString(),
      totalComponents: components.length,
    },
  };

  await fs.writeFile(indexPath, JSON.stringify(index, null, 2));
  return indexPath;
}

function extractSearchableMetadata(
  component: ComponentDefinition,
): SearchableComponent {
  return {
    name: component.name,
    type: component.type,
    description: `${component.name} component migrated from DAISY v1`,
    keywords: generateKeywords(component),
    tags: generateTags(component),
    complexity: component.complexity,
    props: component.props.map(p => p.name),
    businessLogic: component.businessLogic.map(bl => bl.name),
    reactPatterns: component.reactPatterns,
    dependencies: component.dependencies.map(d => d.name),
    migrationStatus: component.migrationStatus,
  };
}

function generateKeywords(component: ComponentDefinition): string[] {
  const keywords = new Set<string>();

  // Add component name variations
  keywords.add(component.name.toLowerCase());
  keywords.add(
    component.name
      .replace(/([A-Z])/g, ' $1')
      .trim()
      .toLowerCase(),
  );

  // Add type
  keywords.add(component.type);

  // Add props
  component.props.forEach(p => keywords.add(p.name));

  // Add business logic names
  component.businessLogic.forEach(bl => keywords.add(bl.name));

  // Add React patterns
  component.reactPatterns.forEach(pattern => keywords.add(pattern));

  // Add dependencies
  component.dependencies.forEach(dep => keywords.add(dep.name));

  return Array.from(keywords);
}

function generateTags(component: ComponentDefinition): string[] {
  const tags = new Set<string>();

  tags.add('migrated');
  tags.add('daisy-v1');
  tags.add('configurator-v2');
  tags.add(component.type);
  tags.add(component.complexity);

  // Add pattern-based tags
  if (component.reactPatterns.includes('useState')) {
    tags.add('react-hooks');
  }
  if (component.reactPatterns.includes('useContext')) {
    tags.add('context-api');
  }

  // Add feature tags
  if (component.businessLogic.length > 0) {
    tags.add('business-logic');
  }
  if (component.props.some(p => p.type.includes('function'))) {
    tags.add('event-handlers');
  }

  return Array.from(tags);
}

/**
 * Generate markdown catalog from search index
 */
export async function generateComponentCatalog(
  index: SearchIndex,
  outputDir: string,
): Promise<string> {
  const catalogPath = join(outputDir, 'component-catalog.md');

  const markdown = `# Component Catalog

Generated: ${index.metadata.generatedAt}
Total Components: ${index.metadata.totalComponents}

## Components by Tier

${generateTierSections(index)}

## Search Index

All components are indexed for discovery:

${generateComponentTable(index)}

---

*Auto-generated by DAISY v1 Migration Pipeline*
`;

  await fs.writeFile(catalogPath, markdown);
  return catalogPath;
}

function generateTierSections(index: SearchIndex): string {
  const complexities = ['simple', 'moderate', 'complex', 'critical'];

  return complexities
    .map(complexity => {
      const components = index.components.filter(
        c => c.complexity === complexity,
      );
      if (components.length === 0) {
        return '';
      }

      return `### ${complexity.toUpperCase()} COMPONENTS

${components.map(c => `- **${c.name}** (${c.type})`).join('\n')}`;
    })
    .filter(Boolean)
    .join('\n\n');
}

function generateComponentTable(index: SearchIndex): string {
  let table = '| Component | Type | Complexity | Props | Tags |\n';
  table += '|-----------|------|------------|-------|------|\n';

  for (const component of index.components) {
    table += `| ${component.name} | ${component.type} | ${component.complexity} | ${component.props.length} | ${component.tags.slice(0, 3).join(', ')} |\n`;
  }

  return table;
}
